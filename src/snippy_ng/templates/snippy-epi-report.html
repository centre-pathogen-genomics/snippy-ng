<!-- This will be a full screen tree viewer wil metadata -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{REPORT_NAME}}</title>

    <!-- Tailwind (CDN for a single-file static page) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Phylocanvas (WebGL) -->
    <script src="https://unpkg.com/@phylocanvas/phylocanvas.gl@latest/dist/bundle.min.js"></script>

    <!-- PhyloJS -->
    <script src="https://unpkg.com/phylojs@latest/lib/dist/phylojs.min.js"></script>

    <!-- Simple DataTables -->
    <link
      href="https://cdn.jsdelivr.net/npm/simple-datatables@latest/dist/style.css"
      rel="stylesheet"
      type="text/css"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/simple-datatables@latest"
      type="text/javascript"
    ></script>

    <!-- Leaflet -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      crossorigin=""
    />
    <script src="https://unpkg.com/leaflet@2.0.0-alpha.1/dist/leaflet-global.js"></script>

    <!-- DATA -->
    <script>
      const treeData = `{{NEWICK}}`;
      const metadata = {{METADATA_JSON}};
      const logs = `{{LOGS}}`;
    </script>
  </head>

  <body class="bg-slate-50 text-slate-900">
    <!-- center vertically -->
    <div
      class="flex flex-row justify-between w-full border bg-white shadow p-2 items-center"
    >
      <div class="p-2">
        <h1 class="text-2xl font-bold">{{REPORT_NAME}}</h1>
        <h2 class="text-sm text-slate-500 mt-1">{{DATETIME}}</h2>
      </div>
      <!-- Info panel -->
      <div
        class="p-2 hover:text-blue-600 text-slate-500 transition-colors duration-200 cursor-pointer"
        id="info-panel"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
          class="size-7"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z"
          />
        </svg>
      </div>
    </div>

    <div
      id="logs-modal"
      class="fixed inset-0 z-[3000] hidden"
      aria-hidden="true"
      role="dialog"
      aria-modal="true"
      aria-labelledby="logs-modal-title"
    >
      <div
        class="absolute inset-0 bg-slate-900/60"
        id="logs-modal-backdrop"
      ></div>
      <div class="relative flex min-h-full items-center justify-center p-4">
        <div
          id="logs-modal-panel"
          class="w-full max-w-4xl rounded-lg bg-white shadow-xl border"
        >
          <div class="flex items-center justify-between border-b px-4 py-3">
            <h3
              id="logs-modal-title"
              class="text-lg font-semibold text-slate-900"
            >
              Information
            </h3>
            <button
              id="logs-modal-close"
              type="button"
              class="rounded p-1 text-slate-500 hover:text-slate-900 hover:bg-slate-100"
              aria-label="Close logs modal"
            >
              âœ•
            </button>
          </div>
          <div class="p-4">
            <p class="mb-3 text-sm text-slate-700">
              This report was generated by <b>{{USER}}</b> using Snippy-NG (v{{VERSION}}) at {{DATETIME}}.
            </p>
            <pre
              id="logs-modal-content"
              class="max-h-[70vh] overflow-auto whitespace-pre-wrap break-words rounded bg-slate-50 border p-3 text-xs text-slate-800"
            ></pre>
          </div>
          <footer
            class="flex flex-row border-t px-4 py-3 text-xs text-slate-500 justify-end"
          >
            <a
              href="https://github.com/centre-pathogen-genomics/snippy-ng"
              target="_blank"
              class="text-blue-600 hover:underline"
              >GitHub
            </a>
          </footer>
        </div>
      </div>
    </div>

    <div
      id="metadata-drop-overlay"
      class="fixed inset-0 z-[2500] hidden bg-slate-700/60 text-white"
      aria-hidden="true"
    >
      <div
        class="flex h-full w-full items-center justify-center p-6 text-center"
      >
        <div
          class="rounded-lg border border-white/30 bg-slate-800/60 px-6 py-4 text-lg font-semibold"
        >
          Drop metadata here
        </div>
      </div>
    </div>

    <div class="p-4 min-h-screen">
      <div
        id="top-row"
        class="flex flex-col md:flex-row gap-2 items-stretch h-[50vh] min-h-[200px]"
      >
        <div
          id="tree-container"
          class="w-full h-full min-h-0 border rounded-lg bg-white shadow overflow-hidden"
        >
          <div id="tree" class="w-full h-full min-h-0"></div>
        </div>
        <div
          id="col-resizer"
          class="hidden md:hidden w-2 h-10 self-center rounded bg-slate-200 hover:bg-slate-300 cursor-col-resize"
          role="separator"
          aria-orientation="vertical"
          aria-label="Resize tree and map width"
        ></div>
        <div
          id="map-panel"
          class="hidden w-full h-full min-h-0 border rounded-lg bg-white shadow overflow-hidden"
        >
          <div id="map" class="w-full h-full min-h-0 rounded"></div>
        </div>
      </div>
      <div class="flex flex-row justify-center">
        <div
          id="row-resizer"
          class="my-2 h-2 w-10 rounded bg-slate-200 hover:bg-slate-300 cursor-row-resize"
          role="separator"
          aria-orientation="horizontal"
          aria-label="Resize tree and map panels"
        ></div>
      </div>
      <div
        id="metadata-table-container"
        class="w-full p-4 border rounded-lg bg-white shadow overflow-auto"
      >
        <table id="metadata-table" class="min-w-full"></table>
      </div>
      <input
        id="metadata-file-input"
        type="file"
        accept=".csv,.tsv,.json"
        multiple
        class="hidden"
      />
    </div>

    <script>
      "use strict";
      // PHYLOCANVAS GL RENDERING LOGIC
      const $ = (id) => document.getElementById(id);

      const els = {
        tree: $("tree"),
        treeContainer: $("tree-container"),
        metadataTableContainer: $("metadata-table-container"),
        metadataTable: $("metadata-table"),
        metadataFileInput: $("metadata-file-input"),
        metadataDropOverlay: $("metadata-drop-overlay"),
        infoPanel: $("info-panel"),
        logsModal: $("logs-modal"),
        logsModalBackdrop: $("logs-modal-backdrop"),
        logsModalPanel: $("logs-modal-panel"),
        logsModalClose: $("logs-modal-close"),
        logsModalContent: $("logs-modal-content"),
        mapPanel: $("map-panel"),
        map: $("map"),
        topRow: $("top-row"),
        rowResizer: $("row-resizer"),
        colResizer: $("col-resizer"),
      };

      let canvas = null; // PhylocanvasGL instance
      let leafletMap = null;
      let mapMarkersLayer = null;
      let isResizingRows = false;
      let isResizingCols = false;
      let phyloJSTree = phylojs.readNewick(treeData);
      let tipNodes = phyloJSTree.leafList || [];
      let tipLabels = tipNodes.map((node) => node.label);
      const normalizeId = (value) =>
        String(value ?? "")
          .trim()
          .replace(/^['"]|['"]$/g, "");
      const tipLabelSet = new Set(tipLabels.map(normalizeId));
      let metadataRows = [];
      let metadataDataTable = null;
      const MIN_PANEL_SIZE = 200;
      const DEFAULT_TREE_WIDTH_PCT = 66;
      const MIN_TREE_WIDTH_PCT = 10;
      const MAX_TREE_WIDTH_PCT = 90;
      const ROW_RESIZER_OFFSET_PX = 8;
      let currentTreeWidthPct = DEFAULT_TREE_WIDTH_PCT;

      function getPhylocanvasCtor() {
        return (
          (window.phylocanvas && window.phylocanvas.PhylocanvasGL) ||
          window.PhylocanvasGL
        );
      }
      function getTreeType() {
        const tt = window.phylocanvas && window.phylocanvas.TreeTypes;
        return tt ? tt.Rectangular : undefined;
      }
      function computeCanvasSize(container) {
        const rect = container.getBoundingClientRect();
        const height = Math.max(MIN_PANEL_SIZE, Math.floor(rect.height || 0));
        return {
          width: Math.max(MIN_PANEL_SIZE, Math.floor(rect.width || 0)),
          height,
        };
      }

      function refreshVisualSizes() {
        if (
          canvas &&
          typeof canvas.setProps === "function" &&
          typeof canvas.render === "function"
        ) {
          canvas.setProps({
            source: treeData,
            size: computeCanvasSize(els.treeContainer || els.tree),
          });
          canvas.render();
          if (typeof canvas.fitInPanel === "function") canvas.fitInPanel();
        }
        if (leafletMap && typeof leafletMap.invalidateSize === "function") {
          leafletMap.invalidateSize();
        }
      }

      function setTreeMapWidths(treePercent) {
        if (!els.treeContainer || !els.mapPanel) return;
        if (window.innerWidth < 768) {
          els.treeContainer.style.width = "";
          els.mapPanel.style.width = "";
          return;
        }
        const clamped = Math.max(
          MIN_TREE_WIDTH_PCT,
          Math.min(MAX_TREE_WIDTH_PCT, treePercent),
        );
        currentTreeWidthPct = clamped;
        els.treeContainer.style.width = `${clamped}%`;
        els.mapPanel.style.width = `${100 - clamped}%`;
      }

      function initColResizer() {
        if (!els.colResizer || !els.topRow) return;

        const onPointerMove = (e) => {
          if (!isResizingCols) return;
          const rect = els.topRow.getBoundingClientRect();
          const nextPercent = ((e.clientX - rect.left) / rect.width) * 100;
          setTreeMapWidths(nextPercent);
          refreshVisualSizes();
        };

        const stopResize = () => {
          if (!isResizingCols) return;
          isResizingCols = false;
          document.body.classList.remove("select-none", "cursor-col-resize");
        };

        els.colResizer.addEventListener("pointerdown", (e) => {
          if (
            window.innerWidth < 768 ||
            (els.mapPanel && els.mapPanel.classList.contains("hidden"))
          )
            return;
          isResizingCols = true;
          document.body.classList.add("select-none", "cursor-col-resize");
          if (els.colResizer.setPointerCapture) {
            els.colResizer.setPointerCapture(e.pointerId);
          }
          e.preventDefault();
        });

        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("pointerup", stopResize);
        window.addEventListener("pointercancel", stopResize);
        window.addEventListener("resize", () => {
          setTreeMapWidths(currentTreeWidthPct);
          refreshVisualSizes();
        });
      }

      function initRowResizer() {
        if (!els.rowResizer || !els.topRow) return;

        const onPointerMove = (e) => {
          if (!isResizingRows) return;
          const top = els.topRow.getBoundingClientRect().top;
          const nextHeight = Math.max(
            MIN_PANEL_SIZE,
            e.clientY - top - ROW_RESIZER_OFFSET_PX,
          );
          els.topRow.style.height = `${Math.round(nextHeight)}px`;
          refreshVisualSizes();
        };

        const stopResize = () => {
          if (!isResizingRows) return;
          isResizingRows = false;
          document.body.classList.remove("select-none", "cursor-row-resize");
        };

        els.rowResizer.addEventListener("pointerdown", (e) => {
          isResizingRows = true;
          document.body.classList.add("select-none", "cursor-row-resize");
          if (els.rowResizer.setPointerCapture) {
            els.rowResizer.setPointerCapture(e.pointerId);
          }
          e.preventDefault();
        });

        window.addEventListener("pointermove", onPointerMove);
        window.addEventListener("pointerup", stopResize);
        window.addEventListener("pointercancel", stopResize);
      }
      function ensureCanvas(newickStr) {
        if (canvas) return canvas;

        const ctor = getPhylocanvasCtor();
        if (!ctor)
          throw new Error(
            "PhylocanvasGL constructor not found. Did the bundle load?",
          );

        const type = getTreeType();
        if (!type)
          throw new Error(
            "phylocanvas.TreeTypes not found. Ensure you are using the standalone bundle.",
          );

        const size = computeCanvasSize(els.treeContainer || els.tree);
        canvas = new ctor(
          els.tree,
          {
            size,
            type,
            source: newickStr,
            showLabels: true,
            showLeafLabels: true,
          },
          [window.phylocanvas.plugins.scalebar],
        );

        return canvas;
      }

      function renderNewick(newickStr) {
        const c = ensureCanvas(newickStr);
        if (
          typeof c.setProps !== "function" ||
          typeof c.render !== "function"
        ) {
          throw new Error(
            "Unexpected PhylocanvasGL API: setProps/render missing.",
          );
        }
        c.setProps({
          source: newickStr,
          size: computeCanvasSize(els.treeContainer || els.tree),
        });
        c.render();
        if (typeof c.fitInPanel === "function") c.fitInPanel();
      }

      function normalizeMetadataRows(raw) {
        if (Array.isArray(raw)) {
          return raw
            .filter((row) => row !== null && row !== undefined)
            .map((row) =>
              typeof row === "object" ? row : { value: String(row) },
            );
        }

        if (raw && typeof raw === "object") {
          return [raw];
        }

        return [];
      }

      function normalizeRowObject(row) {
        const out = {};
        Object.entries(row || {}).forEach(([k, v]) => {
          const key = String(k).trim();
          out[key] = v === null || v === undefined ? "" : String(v).trim();
        });
        const idKey = Object.keys(out).find((k) => k.toLowerCase() === "id");
        if (idKey && idKey !== "id") {
          out.id = out[idKey];
          delete out[idKey];
        }
        if ("id" in out) {
          out.id = normalizeId(out.id);
        }
        return out;
      }

      function parseDelimitedLine(line, delimiter) {
        const out = [];
        let current = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i += 1) {
          const ch = line[i];
          if (ch === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i += 1;
            } else {
              inQuotes = !inQuotes;
            }
            continue;
          }
          if (ch === delimiter && !inQuotes) {
            out.push(current);
            current = "";
            continue;
          }
          current += ch;
        }
        out.push(current);
        return out;
      }

      function parseDelimitedText(text, delimiter) {
        const lines = text
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter((l) => l.length > 0);
        if (!lines.length) return [];
        const headers = parseDelimitedLine(lines[0], delimiter).map((h) =>
          h.trim(),
        );
        return lines.slice(1).map((line) => {
          const values = parseDelimitedLine(line, delimiter);
          const row = {};
          headers.forEach((h, idx) => {
            row[h] = values[idx] ?? "";
          });
          return row;
        });
      }

      function parseTextRowsByType(text, fileName) {
        const lower = String(fileName || "").toLowerCase();
        if (lower.endsWith(".json")) {
          const parsed = JSON.parse(text);
          if (Array.isArray(parsed)) return parsed;
          if (parsed && typeof parsed === "object") return [parsed];
          return [];
        }
        if (lower.endsWith(".tsv")) {
          return parseDelimitedText(text, "\t");
        }
        return parseDelimitedText(text, ",");
      }

      async function parseFileRows(file) {
        const text = await file.text();
        const rows = parseTextRowsByType(text, file.name).map(
          normalizeRowObject,
        );
        return rows;
      }

      function upsertMetadataRows(incomingRows) {
        const rowById = new Map();
        metadataRows.forEach((row) => {
          const id = normalizeId(row.id);
          if (id) rowById.set(id, row);
        });

        let inserted = 0;
        let updated = 0;
        let skipped = 0;
        const newRows = [];

        incomingRows.forEach((row) => {
          const id = normalizeId(row.id);
          if (!id || !tipLabelSet.has(id)) {
            skipped += 1;
            return;
          }

          const normalizedRow = { ...row, id };
          const existingRow = rowById.get(id);
          if (!existingRow) {
            const createdRow = { ...normalizedRow };
            newRows.push(createdRow);
            rowById.set(id, createdRow);
            inserted += 1;
          } else {
            Object.assign(existingRow, normalizedRow);
            updated += 1;
          }
        });

        if (newRows.length) {
          metadataRows = [...newRows, ...metadataRows];
        }

        return { inserted, updated, skipped };
      }

      async function importMetadataFiles(fileList) {
        const files = Array.from(fileList || []);
        if (!files.length) return;

        let changed = false;
        let summaryInserted = 0;
        let summaryUpdated = 0;
        let summarySkipped = 0;

        for (const file of files) {
          try {
            const rows = await parseFileRows(file);
            const rowsWithIdColumn = rows.filter((row) =>
              Object.keys(row).some((k) => k.toLowerCase() === "id"),
            );
            const result = upsertMetadataRows(rowsWithIdColumn);
            summaryInserted += result.inserted;
            summaryUpdated += result.updated;
            summarySkipped +=
              result.skipped + (rows.length - rowsWithIdColumn.length);
            if (result.inserted || result.updated) changed = true;
          } catch (err) {
            console.error(`Failed to parse dropped file ${file.name}:`, err);
          }
        }

        if (changed) {
          renderMetadataTable();
          initMapFromMetadata(metadataRows);
          refreshVisualSizes();
        }

        console.info(
          `Metadata import complete: inserted=${summaryInserted}, updated=${summaryUpdated}, skipped=${summarySkipped}`,
        );
      }

      function initMetadataTable(rawMetadata) {
        if (!els.metadataTable || !window.simpleDatatables) return;

        metadataRows =
          normalizeMetadataRows(rawMetadata).map(normalizeRowObject);
        renderMetadataTable();
      }

      function renderMetadataTable() {
        if (!els.metadataTableContainer || !window.simpleDatatables) return;

        if (
          metadataDataTable &&
          typeof metadataDataTable.destroy === "function"
        ) {
          metadataDataTable.destroy();
          metadataDataTable = null;
        }

        const rows = metadataRows;
        if (!rows.length) {
          els.metadataTableContainer.innerHTML =
            '<p id="metadata-empty" class="text-slate-500">Drop a CSV, TSV, or JSON file to view sample metadata or <a id="metadata-load-link" href="#" class="text-blue-600 hover:underline">click here to load</a></p>';
          els.metadataTable = null;
          return;
        }

        els.metadataTableContainer.innerHTML =
          '<table id="metadata-table" class="min-w-full"></table>';
        els.metadataTable = $("metadata-table");
        if (!els.metadataTable) return;

        const headingsSet = new Set();
        rows.forEach((row) =>
          Object.keys(row).forEach((k) => headingsSet.add(k)),
        );
        const headings = Array.from(headingsSet);
        const data = rows.map((row) =>
          headings.map((h) => {
            const value = row[h];
            if (value === null || value === undefined) return "";
            return typeof value === "object"
              ? JSON.stringify(value)
              : String(value);
          }),
        );

        metadataDataTable = new simpleDatatables.DataTable(els.metadataTable, {
          searchable: true,
          fixedHeight: true,
          data: {
            headings,
            data,
          },
        });
      }

      function initMetadataDropzone() {
        const supported = /\.(csv|tsv|json)$/i;
        let dragDepth = 0;

        const preventDefaults = (e) => {
          e.preventDefault();
          e.stopPropagation();
        };

        const showDropOverlay = () => {
          if (!els.metadataDropOverlay) return;
          els.metadataDropOverlay.classList.remove("hidden");
          els.metadataDropOverlay.setAttribute("aria-hidden", "false");
        };

        const hideDropOverlay = () => {
          if (!els.metadataDropOverlay) return;
          els.metadataDropOverlay.classList.add("hidden");
          els.metadataDropOverlay.setAttribute("aria-hidden", "true");
        };

        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          document.addEventListener(eventName, preventDefaults, false);
        });

        document.addEventListener("dragenter", () => {
          dragDepth += 1;
          showDropOverlay();
        });
        document.addEventListener("dragleave", () => {
          dragDepth = Math.max(0, dragDepth - 1);
          if (dragDepth === 0) {
            hideDropOverlay();
          }
        });
        document.addEventListener("drop", async (e) => {
          dragDepth = 0;
          hideDropOverlay();
          const files = Array.from(e.dataTransfer?.files || []).filter((f) =>
            supported.test(f.name),
          );
          if (!files.length) return;
          await importMetadataFiles(files);
        });

        if (els.metadataTableContainer && els.metadataFileInput) {
          els.metadataTableContainer.addEventListener("click", (e) => {
            const target = e.target;
            if (
              target instanceof HTMLElement &&
              target.id === "metadata-load-link"
            ) {
              e.preventDefault();
              els.metadataFileInput.click();
            }
          });

          els.metadataFileInput.addEventListener("change", async () => {
            const files = Array.from(els.metadataFileInput.files || []);
            if (!files.length) return;
            await importMetadataFiles(files);
            els.metadataFileInput.value = "";
          });
        }
      }

      function findCoordinateKeys(rows) {
        if (!rows.length) return { latKey: null, lonKey: null };
        const keys = Array.from(
          rows.reduce((acc, row) => {
            Object.keys(row || {}).forEach((k) => acc.add(k));
            return acc;
          }, new Set()),
        );
        const lowerToOriginal = new Map(keys.map((k) => [k.toLowerCase(), k]));

        const latCandidates = ["latitude", "lat", "y"];
        const lonCandidates = ["longitude", "lon", "lng", "long", "x"];

        const latKey = latCandidates.find((k) => lowerToOriginal.has(k));
        const lonKey = lonCandidates.find((k) => lowerToOriginal.has(k));

        return {
          latKey: latKey ? lowerToOriginal.get(latKey) : null,
          lonKey: lonKey ? lowerToOriginal.get(lonKey) : null,
        };
      }

      function parseCoordinate(value) {
        if (value === null || value === undefined) return null;
        const n = Number(value);
        return Number.isFinite(n) ? n : null;
      }

      function createLeafletMap(elementId, center, zoom) {
        if (typeof L.map === "function") {
          return L.map(elementId).setView(center, zoom);
        }
        return new L.Map(elementId).setView(center, zoom);
      }

      function createLeafletTileLayer(url, options) {
        if (typeof L.tileLayer === "function") {
          return L.tileLayer(url, options);
        }
        return new L.TileLayer(url, options);
      }

      function createLeafletMarker(latLng, options = {}) {
        if (typeof L.marker === "function") {
          return L.marker(latLng, options);
        }
        return new L.Marker(latLng, options);
      }

      function createLeafletDivIcon(options = {}) {
        if (typeof L.divIcon === "function") {
          return L.divIcon(options);
        }
        return new L.DivIcon(options);
      }

      function createLeafletLayerGroup() {
        if (typeof L.layerGroup === "function") {
          return L.layerGroup();
        }
        return new L.LayerGroup();
      }

      function initMapFromMetadata(rawMetadata) {
        if (!els.mapPanel || !els.map || typeof L === "undefined") {
          console.warn(
            "Leaflet library not found. Map cannot be initialized.",
          );
          return;
        }

        const rows = (
          metadataRows.length
            ? metadataRows
            : normalizeMetadataRows(rawMetadata).map(normalizeRowObject)
        ).filter((r) => typeof r === "object");
        console.info(`Initializing map with ${rows} metadata rows.`);
        console.info(JSON.stringify(rows, null, 2));
        const { latKey, lonKey } = findCoordinateKeys(rows);
        if (!latKey || !lonKey) {
          els.mapPanel.classList.add("hidden");
          if (els.colResizer) {
            els.colResizer.classList.remove("md:block");
            els.colResizer.classList.add("md:hidden");
          }
          if (els.treeContainer) {
            els.treeContainer.style.width = "";
          }
          console.info(
            "No valid latitude/longitude keys found in metadata. Map will be hidden.",
          );
          return;
        }

        const points = rows
          .map((row) => {
            const lat = parseCoordinate(row[latKey]);
            const lon = parseCoordinate(row[lonKey]);
            if (lat === null || lon === null) return null;
            if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return null;
            const label =
              row.sample_id ?? row.id ?? row.sample ?? row.name ?? "sample";
            return { lat, lon, label };
          })
          .filter(Boolean);

        console.info(`Found ${points} valid coordinate points in metadata.`);

        if (!points.length) {
          els.mapPanel.classList.add("hidden");
          if (els.colResizer) {
            els.colResizer.classList.remove("md:block");
            els.colResizer.classList.add("md:hidden");
          }
          if (els.treeContainer) {
            els.treeContainer.style.width = "";
          }
          return;
        }

        els.mapPanel.classList.remove("hidden");
        if (els.colResizer) {
          els.colResizer.classList.remove("md:hidden");
          els.colResizer.classList.add("md:block");
        }
        setTreeMapWidths(DEFAULT_TREE_WIDTH_PCT);
        refreshVisualSizes();

        if (!leafletMap) {
          leafletMap = createLeafletMap(
            "map",
            [points[0].lat, points[0].lon],
            2,
          );
          createLeafletTileLayer(
            "https://tile.openstreetmap.org/{z}/{x}/{y}.png",
            {
              maxZoom: 19,
              attribution:
                '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
            },
          ).addTo(leafletMap);
        }

        if (!mapMarkersLayer) {
          mapMarkersLayer = createLeafletLayerGroup().addTo(leafletMap);
        } else if (typeof mapMarkersLayer.clearLayers === "function") {
          mapMarkersLayer.clearLayers();
        }

        const latLngs = [];
        points.forEach((p) => {
          latLngs.push([p.lat, p.lon]);
          const labelIcon = createLeafletDivIcon({
            className: "",
            html: `<div class="inline-flex flex-col items-center">
                <div class="px-2 py-0.5 rounded bg-white/90 border border-slate-300 text-xs font-medium text-slate-800 shadow-sm whitespace-nowrap">${String(p.label)}</div>
              </div>`,
            iconSize: [0, 0],
            iconAnchor: [0, 0],
          });
          createLeafletMarker([p.lat, p.lon], {
            icon: labelIcon,
          }).addTo(mapMarkersLayer);
        });

        if (latLngs.length === 1) {
          leafletMap.setView(latLngs[0], 6);
        } else {
          leafletMap.fitBounds(latLngs, { padding: [20, 20] });
        }

        // Ensure final sizes are correct after DOM/layout settles.
        requestAnimationFrame(() => {
          refreshVisualSizes();
        });
      }

      function openLogsModal() {
        if (!els.logsModal) return;
        if (els.logsModalContent) {
          const logsValue = logs == null ? "" : String(logs).trim();
          const hasLogs = logsValue.length > 0 && logsValue.toLowerCase() !== "null";
          if (hasLogs) {
            els.logsModalContent.classList.remove("hidden");
            els.logsModalContent.textContent = logsValue;
          } else {
            els.logsModalContent.classList.add("hidden");
            els.logsModalContent.textContent = "";
          }
        }
        els.logsModal.classList.remove("hidden");
        els.logsModal.setAttribute("aria-hidden", "false");
      }

      function closeLogsModal() {
        if (!els.logsModal) return;
        els.logsModal.classList.add("hidden");
        els.logsModal.setAttribute("aria-hidden", "true");
      }

      function initLogsModal() {
        if (!els.infoPanel || !els.logsModal) return;
        els.infoPanel.addEventListener("click", openLogsModal);
        if (els.logsModalClose) {
          els.logsModalClose.addEventListener("click", closeLogsModal);
        }
        els.logsModal.addEventListener("click", (e) => {
          const target = e.target;
          if (
            els.logsModalPanel &&
            target instanceof Node &&
            !els.logsModalPanel.contains(target)
          ) {
            closeLogsModal();
          }
        });
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") closeLogsModal();
        });
      }

      // Initial render
      renderNewick(treeData);
      initMetadataTable(metadata);
      initMapFromMetadata(metadata);
      initLogsModal();
      initRowResizer();
      initColResizer();
      initMetadataDropzone();
    </script>
  </body>
</html>
